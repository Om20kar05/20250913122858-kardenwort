# ==============================================================================
#  Lemma Override Rules
# ==============================================================================
#
# This file allows for precise control over the lemmatization process.
# It uses a powerful 4-column, tab-separated format to define rules.
#
# ==============================================================================
#  Rule Format
# ==============================================================================
#
# Each rule is defined on a single line with four columns separated by TABs.
#
# Format:
# Result_Lemma <TAB> Original_Word <TAB> Target_Lemma <TAB> [Optional_Context]
#
# --- Column Definitions ---
#
# 1. Result_Lemma:
#    The initial lemma or component part identified by the system. This can be
#    the output of the standard lemmatizer or a component from the compound splitter.
#
# 2. Original_Word:
#    The original, inflected word as it appeared in the source text.
#
# 3. Target_Lemma:
#    The new, desired lemma that should be used instead. This column is mandatory.
#
# 4. Context:
#    An optional substring. If provided, the rule will only apply if this
#    substring is present anywhere in the sentence.
#
# By filling in different combinations of the first two columns, you can create
# rules with varying levels of specificity.
#
# ==============================================================================
#  How it works & Rule Precedence
# ==============================================================================
#
# Before detailing the priority, it's important to understand two types of rules:
#
# - A "Global Rule" is a rule where the 4th column (Context) is empty.
#   It applies every time its conditions are met.
# - A "Contextual Rule" is a rule where the 4th column is filled.
#   It applies only if its conditions are met AND the context string is
#   found in the sentence.
#
# The system evaluates rules in a strict order of priority. The first rule
# that matches a word will be applied, and no further rules will be checked.
#
# --- Priority Levels ---
#
# 1. Highest Priority: Specific Match (Result_Lemma + Original_Word)
#    - A rule where both `Result_Lemma` and `Original_Word` are specified.
#    - This is the most precise rule type. It targets a specific source word
#      that was lemmatized to a specific (potentially incorrect) result.
#    - Example: `Donaudampfschifffahrtsgesellschaftskapitan	Donaudampfschifffahrtsgesellschaftskapitäne	Donaudampfschifffahrtsgesellschaftskapitän	präzise Navigation`
#      "When the word 'Donaudampfschifffahrtsgesellschaftskapitäne' is lemmatized to 'Donaudampfschifffahrtsgesellschaftskapitan', override it with 'Donaudampfschifffahrtsgesellschaftskapitän', but only if the sentence contains 'präzise Navigation'."
#
# 2. Medium Priority: Source Word Match (Original_Word only)
#    - A rule where `Original_Word` is specified, but `Result_Lemma` is empty.
#    - This targets a specific word, regardless of what the default lemmatizer produces.
#    - Example: `	Übungsaufgaben	Übungsaufgabe	`
#      "Whenever the word 'Übungsaufgaben' appears, its lemma must be 'Übungsaufgabe'."
#
# 3. Low Priority: Result Lemma Match (Result_Lemma only)
#    - A rule where `Result_Lemma` is specified, but `Original_Word` is empty.
#    - This acts as a broad "find and replace" for any lemma produced by the system.
#    - Example: `Date		Daten	`
#      "If the system ever produces 'Date' as a lemma or component part for any word,
#       always replace it with 'Daten'." This single rule would fix the component in both
#       'Bilddaten' and 'Audiodaten', but it would also apply to any other word that
#       might produce the lemma 'Date', which could be undesirable in some contexts.
#
# --- Context vs. Global Rules within each Priority ---
#
# For any of the priority levels above, the system first looks for a contextual
# rule before a global one.
#
# 1. Contextual Match (Checked First):
#    The system checks for rules where the 4th column (Context) is filled. The
#    context is treated as a flexible substring, which can be a single word,
#    multiple words, or a phrase with punctuation. The rule applies if this exact
#    substring is found anywhere in the sentence—its position relative to the
#    original word (before, after, or including it) does not matter.
#
# 2. Global Match (Fallback):
#    If no contextual rule matches, the system looks for a global rule
#    (where the 4th column is empty).
#
# --- Final Fallback ---
#
# 4. Default System Processing:
#    If no override rules match at all, the original output from the lemmatizer
#    or splitter is used.
#
# ==============================================================================
#  Advanced Matching with Regular Expressions (regex)
# ==============================================================================
#
# For ultimate flexibility, the system supports regular expressions in both the
# `Original_Word` (column 2) and `Context` (column 4) fields.
#
# To enable regex mode for a field, simply prefix its content with "regex:".
#
# The behavior of "regex:" is context-dependent:
# - In column 2, it matches against the single Original_Word.
# - In column 4, it matches against the entire sentence.
#
# --- Part 1: Regex on Original_Word (Column 2) ---
#
# This is extremely powerful for creating a single rule that applies to many
# different words, or for correcting components inside compound words safely.
#
# - Example: Safely correcting a component in compound words.
#   Problem: The compound splitter sometimes incorrectly identifies 'Daten' as 'Date'.
#   However, "Date" is a valid German word (the fruit), so a broad rule like
#   `Date		Daten` is unsafe.
#
#   Old, repetitive solution:
#   # Date	Audiodaten	Daten
#   # Date	Bilddaten	Daten
#   # Date	Datenbanken	Daten
#   # ... and so on for every new compound word.
#
#   New, elegant solution with regex:
#   Date	regex:(?i)\w*daten\w*	Daten
#
#   How it works:
#   This Priority 1 rule says: "If the system produces a component 'Date' (col 1)
#   from an `Original_Word` (col 2) that matches the pattern `(?i)\w*daten\w*`,
#   then replace the component's lemma with 'Daten' (col 3)."
#   - `(?i)`: case-insensitive match.
#   - `\w*daten\w*`: matches any word containing "daten".
#   This single line correctly fixes `Audiodaten`, `Bilddaten`, `Metadaten`, etc.,
#   without affecting the standalone word "Date".
#
# - A Priority 2 regex rule is also possible:
#   `	regex:(?i)\w*daten\w*	Daten`
#   This is a broader, more aggressive rule: "For any `Original_Word` containing
#   'daten', force its lemma to be 'Daten'." This would incorrectly change
#   "Soldaten" to "Daten", so use with caution.
#
# --- Part 2: Regex on Context (Column 4) ---
#
# This allows creating rules that depend on the structure of the sentence.
#
# - Example: Match if a word is not at the start of a sentence.
#   Problem: You want to ensure `Ihr` (formal "your") keeps its capitalization
#   when it's in the middle of a sentence, but not interfere when it's at the
#   start (where it could be `ihr` - "you all").
#
#   Rule:
#   	Ihr	Ihr	regex:(?<!^)Ihr
#
#   How it works:
#   The regex `(?<!^)Ihr` uses a negative lookbehind `(?<!^)` to assert that
#   the string "Ihr" is not preceded by the start of the line `^`.
#   - Sentence "Wir brauchen Ihr Feedback." -> MATCH.
#   - Sentence "Ihr seid willkommen." -> NO MATCH.
#
# --- Whitespace Handling with Regex ---
#
# - Standard fields (no "regex:" prefix): Leading/trailing whitespace is removed.
# - Regex fields ("regex:" prefix): The pattern is used exactly as written.
#   This gives you full control.
#
# ==============================================================================
#  Mechanics & Best Practices
# ==============================================================================
#
# 1. Matching is Case-Sensitive (unless using regex flags like `(?i)`)
#    All matching for words, lemmas, and contexts is strictly case-sensitive.
#
# 2. Rule Order Can Matter
#    The file is processed top-to-bottom. While the priority system handles most
#    cases, if you have two rules with the exact same priority, the one that
#    appears first in the file will be applied.
#
# ==============================================================================
#  User-Defined Override Rules
# ==============================================================================
#
# Add your override rules below.
# To activate a rule, remove the '#' at the beginning of the line.
#
# Format: Result_Lemma <TAB> Original_Word <TAB> Target_Lemma <TAB> [Context]

# --- Rules for whole words (unconditional) ---
# Logic: "For this Original_Word, always use this Target_Lemma"
# Format: <empty> <TAB> Original_Word <TAB> Target_Lemma <TAB> <empty>
#-------------------------------------------------------------------------------
	Dritte	Dritte	
	Übungsaufgaben	Übungsaufgabe	
	Bilddaten	Bilddaten	
	Audiodaten	Audiodaten	
	Ihrer	Ihr	
	Substantiven	Substantiv	
	Substantive	Substantiv	
	Englischen	Englisch	
	Ihre	Ihr	

# --- Rules for whole words (conditional, with context) ---
# Logic: "For this Original_Word, use Target_Lemma, but only if Context is in the sentence"
# Format: <empty> <TAB> Original_Word <TAB> Target_Lemma <TAB> Context
#-------------------------------------------------------------------------------
# Die Fischer kennen die Austernbanken vor der Küste sehr gut und fahren sie gezielt an.
	Austernbanken	Austernbanke	Küste

# Enforce lemma 'Ihr'/'Sie' only when it is not at the start of a sentence
	Ihr	Ihr	regex:(?<!^)Ihr
	Sie	Sie	regex:(?<!^)Sie

# --- Rules for lemma parts (unconditional) ---
aller		all	

# --- Very specific rule (Highest Priority), also contextual ---
# Format: Result_Lemma <TAB> Original_Word <TAB> Target_Lemma <TAB> Context
#-------------------------------------------------------------------------------
Donaudampfschifffahrtsgesellschaftskapitan	Donaudampfschifffahrtsgesellschaftskapitäne	Donaudampfschifffahrtsgesellschaftskapitän	präzise Navigation

# --- Rules for parts of compound words ---
# Logic: Correct a component 'Result_Lemma' from a specific 'Original_Word'
# Format: Result_Lemma <TAB> Original_Word <TAB> Target_Lemma <TAB> <empty>
#-------------------------------------------------------------------------------
# Safely correct 'Date' -> 'Daten' in all compound words containing 'daten'
Date	regex:(?i)\w*daten\w*	Daten